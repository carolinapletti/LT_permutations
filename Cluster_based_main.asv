% permutation tests for fNIRS wavelet transform coherence data

% for interaction data: irrespective of group, compare all participants
% with random pairs (first calculate the random pairs)
% difference between real pairs and averaged random permutation pairs will
% tell us in which frequencies and time points there where differences
% between real interacting participants and fake participants pairs -> so
% it's a t-test, not an ANOVA!

% for video data: compare participants watching videos together with
% participants watching videos separately (since they are practically the
% same as randomly permuted pairs - same stimuli but they don't even see
% each other) -> again t-test, not ANOVA!

% for interaction data:

% load all interaction_long data

clear all

% set statistical parameters
% p-value
pval = 0.05;

% convert p-value to Z value
% if you don't have the stats toolbox, set zval=1.6449;
zval = abs(norminv(pval));

% number of permutations
n_permutes = 1000;


% create empty structure that will contain all necessary parameters to load
% the data
cfg = [];
cfg.groups = {'IC','IL','NIC','NIL'}; %names of the groups to be analyzed. Should correspond to subfolder names inside the raw data folder below
cfg.segment = 'interaction_long'; %segment of the experiment to be analyzed. Options: laughter, interaction, interaction_long

% --------------------------------------------------------------------
%set all paths for loading and saving data, add folder with functions to the path. Change paths in the config_paths
%function and following part of the script based on necessity 

sel = false;

while sel == false
    fprintf('\nPlease select one option:\n');
    fprintf('[1] - Carolina''s workspace at the uni\n');
    fprintf('[2] - Carolina''s workspace at home\n');
    fprintf('[3] - None of the above\n');

    x = input('Option: ');

    switch x
        case 1
            sel = true;
            cfg = Cluster_config_paths(cfg, 1);
        case 2
            sel = true;
            cfg = Cluster_config_paths(cfg, 0)
        case 3
            sel = true;
            fprintf('please change this script and the config_path function so that the paths match with where you store data, toolboxes and scripts!');
        return;
        otherwise
            cprintf([1,0.5,0], 'Wrong input!\n');
        return
    end
end

[data_cell, data_RPA_cell] = Cluster_data_load(cfg);


% statistics via permutation testing

[diffmap_cell, permmaps_cell] = Cluster_permut n_permutes,  pval zval


% Apply cellfun to extract columns from 4 onwards for each matrix in data_cell
data_cell_trimmed = cellfun(@(x) cellfun(@(y) y(:, 4:end), x, 'UniformOutput', false), ...
                        data_cell, 'UniformOutput', false);
data_cell_trimmed_RPA = cellfun(@(x) cellfun(@(y) y(:, 4:end), x, 'UniformOutput', false), ...
                        data_RPA_cell, 'UniformOutput', false);
%find cells with NaNs in data_cell_trimmed and make sure that the same cells have NaNs also in data_cell_trimmed_RPA                    

% Loop through the outer cells
for j = 1:length(data_cell_trimmed)
    % Loop through the inner cells
    for k = 1:length(data_cell_trimmed{1,1})
        % Check if the corresponding matrix in cell_one contains NaN
        nanMask = isnan(data_cell_trimmed{j}{k}); % Create a mask of NaN positions

        % Update cell_two at the same position using the mask
        data_cell_trimmed_RPA{j}{k}(nanMask) = NaN;
    end
end

%create cell of differece maps, one per channel
diffmap_cell = cell(1, length(data_cell_trimmed));

%create cell of permutations data
permmaps_cell = cell(1, length(data_cell_trimmed));



%for each channel
for i = 1:length(data_cell_trimmed)
    
    %concatenate all participant cells into one matrix
    % Convert the cell array to a 3D matrix
    channelMatrix = cat(3, data_cell_trimmed{1,i}{:});
    channelMatrix_RPA = cat(3, data_cell_trimmed_RPA{1,i}{:});
    channelMatrix_all = cat(3, channelMatrix, channelMatrix_RPA);
    
    % some visualization of the raw power data

    % for convenience, compute the difference in power between the two channels
    diffmap = squeeze(mean(channelMatrix(:,:,:),3 , "omitnan")) - squeeze(mean(channelMatrix_RPA(:,:,:),3 , "omitnan"));
    diffmap_cell{1,i} = diffmap;
    
    clim = [0 1300];
    xlim = [0 1]; % for plotting

    figure(2), clf
    subplot(221)
    imagesc(1248,15,squeeze(mean( channelMatrix(:,:,:),3, "omitnan" )))

    subplot(222)
    imagesc(1248,15,squeeze(mean( channelMatrix_RPA(:,:,:),3, "omitnan" )))

    subplot(223)
    imagesc(1248,15,diffmap)


    % initialize null hypothesis maps (number of permutations x numbers of
    % periods x time points
    permmaps = zeros(n_permutes,size(channelMatrix_all,1),size(channelMatrix_all,2));
    
    % generate maps under the null hypothesis
    for permi = 1:n_permutes
    
        % randomize trials, which also randomly assigns trials to channels
        randorder = randperm(size(channelMatrix_all,3));
        temp_channelMatrix_all = channelMatrix_all(:,:,randorder);
    
        % compute the "difference" map
        % what is the difference under the null hypothesis?
        npart = size(channelMatrix,3);
        permmaps(permi,:,:) = squeeze( mean(temp_channelMatrix_all(:,:,1:npart),3, "omitnan") - mean(temp_channelMatrix_all(:,:,npart+1:end),3, "omitnan") );
    end
    
    permmaps_cell{1,i} = permmaps;
    
end


%% make some space clearing unnecessary variables
clearvars -except diffmap_cell n_permutes permmaps_cell pval zval


%% compute z- and p-values based on normalized distance to H0 distributions (per pixel)

%prepare cells to store results
mean_h0_cell = cell(1,length(diffmap_cell));
std_h0_cell = cell(1,length(diffmap_cell));
zmap_cell = cell(1,length(diffmap_cell));
max_cluster_sizes_cell = cell(1,length(diffmap_cell));


%for each channel

for i = 1:length(diffmap_cell)
    
    %extract relevant data matrices
    permmaps = permmaps_cell{1,i};
    diffmap = diffmap_cell{1,i};
    
    % compute mean and standard deviation maps
    mean_h0 = squeeze(mean(permmaps, "omitnan"));
    mean_h0_cell{1,i} = mean_h0;
    std_h0  = squeeze(std(permmaps, "omitnan"));
    std_h0_cell{1,i} = std_h0;

    % now threshold real data...
    % first Z-score
    zmap = (diffmap-mean_h0) ./ std_h0;

    % threshold image at p-value, by setting subthreshold values to 0
    zmap(abs(zmap)<zval) = 0;

    % also set all NaNs to 0 in the z map
    zmap(isnan(zmap))=0;
    
    zmap_cell{1,i} = zmap;

    %%% now some plotting...

    figure(3), clf

    subplot(121)
    imagesc(1248,15,diffmap);
    xlabel('Time (ms)'), ylabel('Frequency (Hz)')
    title('TF map of real power values')

    subplot(122)
    imagesc(1248,15,zmap);
    xlabel('Time (ms)'), ylabel('Frequency (Hz)')
    title('Thresholded TF map of Z-values')

    % initialize matrices for cluster-based correction
    max_cluster_sizes = zeros(1,n_permutes);


    % loop through permutations
    for permi = 1:n_permutes
    
        % take each permutation map, and transform to Z
        threshimg = squeeze(permmaps(permi,:,:));
        threshimg = (threshimg-mean_h0)./std_h0;
    
        % threshold image at p-value
        threshimg(abs(threshimg)<zval) = 0;
    
    
        % find clusters (need image processing toolbox for this!)
        islands = bwconncomp(threshimg);
        if numel(islands.PixelIdxList)>0
        
            % count sizes of clusters
            tempclustsizes = cellfun(@length,islands.PixelIdxList);
        
            % store size of biggest cluster
            max_cluster_sizes(permi) = max(tempclustsizes);
        end
    end
    max_cluster_sizes_cell{1,i} = max_cluster_sizes;
end


%% make some space clearing unnecessary variables
clearvars -except 

%% show histograph of maximum cluster sizes for each channel

for i = 1:length(diffmap_cell)
    
    max_cluster_sizes = max_cluster_sizes_cell{1,i};

    figure, clf
    histogram(max_cluster_sizes,20)
    xlabel(sprintf('Maximum cluster sizes channel %d', i)), ylabel('Number of observations')
    title(sprintf('Expected cluster sizes under the null hypothesis for channel %d', i))


    % find cluster threshold (need image processing toolbox for this!)
    % based on p-value and null hypothesis distribution
    cluster_thresh = prctile(max_cluster_sizes,100-(100*pval));

end
%% plots with multiple comparisons corrections

% now find clusters in the real thresholded zmap
% if they are "too small" set them to zero
islands = bwconncomp(zmap);
for i=1:islands.NumObjects
    % if real clusters are too small, remove them by setting to zero!
    if numel(islands.PixelIdxList{i})<cluster_thresh
        zmap(islands.PixelIdxList{i})=0;
    end
end

% plot tresholded results
figure(4), clf
subplot(221)
imagesc(1248,15,diffmap)
xlabel('Time (ms)'), ylabel('Frequency (Hz)')
title('TF power, no thresholding') 


subplot(222)
imagesc(1248,15,diffmap)
hold on
contour(1248,15,logical(zmap),1,'linecolor','k')
xlabel('Time (ms)'), ylabel('Frequency (Hz)')
title('TF power with contour')


subplot(223)
imagesc(1248,15,zmap)
xlabel('Time (ms)'), ylabel('Frequency (Hz)')
title('z-map, thresholded')



